using System;
using System.Collections.Generic;

namespace AlgorithmsDataStructures
{
    /// <summary>
    /// Динамические массивы
    /// </summary>
    #region Теория
    //У списков есть свои неоспоримые преимущества, но есть и один недостаток -- мы не можем обратиться к конкретному элементу быстро, по индексу, одним обращением. Сложность операции выборки i-го элемента, очевидно, O(n) -- нам надо, в наихудшем случае, пробежаться по всему списку с начала до конца. А массивы через индексирование обычно предоставляют меру O(1) -- то есть не зависящую от размера массива. И мы при этом хотим работать с массивами, как с динамическими объектами -- чтобы они автоматически расширялись при добавлении в них элемента.//    Практически во всех современных языках поддерживается тип данных "список", как минимум на уровне стандартных библиотек, который в принципе полностью отвечает требованиям динамического массива.Список обычно индексируется, позволяет добавлять элементы в позицию по индексу, автоматически расширяется когда в него добавляются новые элементы, и сжимается при удалении элементов.
    //   Схемы реаллокации
    //   Схем увеличения буфера (реаллокации массива) две: аддитивная и мультипликативная.
    //   Аддитивная схема обычно применяется, когда размер массива небольшой, и расходы на реаллокацию невелики.В таком случае экономичнее увеличивать его размер относительно небольшими фиксированными порциями.Мультипликативная схема подразумевает достаточно сильное изменение размера -- в разы, так как реаллокация крупного массива потребует существенных ресурсов. Обычно он удваивается.Пример мультипликативной схемы, принятой в стандартной библиотеке Java:
    //   size = (size * 3) / 2 + 1
    //   Часто применяется и отношение "золотого сечения" 1,618.
    //   В целом, политика регулирования такого размера сильно зависит от конкретной решаемой задачи.
    //   Важно.В тестах используется схема, когда увеличение буфера происходит в два раза, а уменьшение в полтора раза (текущее значение размера буфера делится на 1.5, и результат приводится к целому типу, никаких округлений!). При этом сохраняем минимальную ёмкость 16 элементов.То есть если после деления на 1.5 получается меньше 16 элементов, то принимаем новый размер буфера 16 элементов.
    // Увеличение буфера выполняем, когда он весь полностью заполнен, и выполняется попытка добавления.Сокращение буфера выполняем, когда его заполненность после операции удаления станет строго меньше, чем заданный процент заполнения. В тестах используйте этот процент равным 50%.
    //Придерживайтесь этой схемы в своём коде для успешного тестирования.
    //2. Анализ мультипликативной схемы с помощью банковского метода
    // В общем случае недостаток мультипликативной схемы в том, что размер массива будет увеличиваться в геометрической прогрессии, а желаемая сложность O(1) в реальности будет o(1) (в среднем). Если вставка попадёт на реаллокацию, задержка времени может быть существенной.Поэтому в противовес так называемому агрегированному методу анализа сложности(и, соответственно выбору метода реаллокации), который подразумевает вычисление итоговой суммарной оценки всех операций(общее время работы) применяют банковский метод.
    //Его идея в том, что дешёвые операции мы делаем чуть дороже, чем они реально стоят, а дорогие наоборот подешевле.При этом удаётся поддерживать всё время положительный баланс, несмотря на то, что дорогие операции по абсолютной цене могут уводить его в минус.
    //Например, каждый случай вставки элемента, когда реаллокации не происходит, и каждый случай копирования элемента при копировании, можно оценивать не в одну условную операцию записи, а в три.Как только накапливается достаточная сумма, чтобы оплатить очередную реаллокацию, она выполняется. Причём цена её зависит от количества элементов в массиве и выбирается например, как степень двойки, не превышающая новый размер буфера.
    //3. Реализация динамического массива на практике
    //Мы смоделируем работу динамического массива вручную.
    //В классе DynArray потребуются три поля: count -- текущее количество элементов в массиве, capacity -- текущая ёмкость буфера (исходно 16 единиц), и array -- по сути, указатель на блок памяти нужной ёмкости.
    //Как лучше реализовать поле array? Дело в том, что не во всех языках разрешено напрямую работать с памятью.
    //Стандартный рекомендуемый здесь приём -- array хранит массив фиксированной длины с объектами некоторого базового типа, к которому приводятся все остальные типы.Когда мы расширяем или уменьшаем размер array, мы просто пересоздаём его с новым размером, и затем копируем объекты(по сути, указатели) в массив нового размера.Это копирование выполняется очень быстро и практически не требует ресурсов.Более того, во многих языках имеется стандартная операция копирования массивов.
    //4. Общие рекомендации
    //Если вам понадобится запрограммировать некоторую структуру данных, которую удобно сделать как связный список или как динамический массив, что лучше выбрать? Если элементов немного, то проще использовать самый обычный массив фиксированного размера с гарантированным запасом места (не важно, будет его размер 100 или 200 элементов, если их точно не будет больше верхней границы). А если их наоборот очень много, то плох будет и список, и динамический массив: первый слишком долго перебирать, а второй слишком долго расширять.Поэтому на практике например используется гибридная схема динамический "массиво-список": список составляется не из отдельных элементов, а из блоков (массивов фиксированного размера), которые сцепляются в список по мере роста числа элементов.При этом сам список относительно небольшой, поэтому его сканирование за O(N) вполне допустимо, а наращивание размера за счёт добавления фиксированных блоков выполняется за O(1). Внутри же этих блоков обращение к элементам также осуществляется за O(1). Но при этом, конечно, придётся пожертвовать временем доступа к конкретным значениям.
    //В целом, очень полезная практика -- комбинирование разных структур данных в одной, прежде всего из соображений масштабируемости.Когда данных для хранения слишком много, использовать одну классическую, "чистую" базовую структуру данных не всегда оптимально. Надо подумать, можно ли выделить во входных данных какие-то блоки, в которых имеется своя внутренняя структура, внутренняя организация, и применять для них наиболее подходящие типы данных, которые уже глобально связывать чем-то простым вроде списка или массива. Старайтесь применять такой подход и в дальнейшем, прикидывайте, как можно формировать эффективные композиции различных структур данных.
    #endregion
    #region Задания.
    //1. Нам потребуются такие базовые методы:
    //- формирование блока памяти заданного размера: MakeArray(int new_capacity). Метод меняет размер массива array, копируя при необходимости текущие объекты вышеописанным способом;
    //- получение объекта по его индексу GetItem(int i). В этот метод встроим проверку корректности индекса в рамках границ, и генерацию соответствующего исключения, если обращение некорректно;
    //- добавление нового элемента в конец массива, метод Append(item) .
    //Важно.В тестах используется схема, когда увеличение буфера происходит в два раза, а уменьшение в полтора раза(текущее значение размера буфера делится на 1.5, и результат приводится к целому типу). При этом сохраняем минимальную ёмкость 16 элементов.
    //Придерживайтесь этой схемы в своём коде для успешного тестирования.
    //2. Добавьте метод Insert(item, i), который вставляет в i-ю позицию объект item, сдвигая вперёд все последующие элементы.Учтите, что новая длина массива может превысить размер буфера.
    //3. Добавьте метод Remove(i), который удаляет объект из i-й позиции, при необходимости выполняя сжатие буфера.
    //В обоих случаях, если индекс i лежит вне допустимых границ, генерируйте исключение.
    //Важно, единственное исключение: для метода Insert() параметр i может принимать значение, равное длине рабочего массива count, в таком случае добавление происходит в его хвост.
    //4. Оцените меры сложности для этих двух методов.
    //5. Напишите тесты, проверяющие работу методов Insert() и Remove():
    //-- вставка элемента, когда в итоге размер буфера не превышен (проверьте также размер буфера);
    //-- вставка элемента, когда в результате превышен размер буфера(проверьте также корректное изменение размера буфера);
    //-- попытка вставки элемента в недопустимую позицию;
    //-- удаление элемента, когда в результате размер буфера остаётся прежним(проверьте также размер буфера);
    //-- удаление элемента, когда в результате понижается размер буфера(проверьте также корректное изменение размера буфера);
    //-- попытка удаления элемента в недопустимой позиции.
    #endregion

    public class DynArray<T>
    {
        public T[] array;
        public int count;
        public int capacity;

        public DynArray()
        {
            count = 0;
            MakeArray(16);
        }
        /// <summary>
        /// Метод формирования блока памяти заданного размера
        /// Стандартный рекомендуемый здесь приём -- array хранит массив фиксированной длины с объектами некоторого базового типа, к которому приводятся все остальные типы. Когда мы расширяем или уменьшаем размер array, мы просто пересоздаём его с новым размером, и затем копируем объекты (по сути, указатели) в массив нового размера. Это копирование выполняется очень быстро и практически не требует ресурсов. Более того, во многих языках имеется стандартная операция копирования массивов.
        /// </summary>
        /// <param name="new_capacity"></param>
        public void MakeArray(int new_capacity)
        {
            // ваш код
        }
        /// <summary>
        /// Метод получения объекта по его индексу: 
        /// В этот метод встроим проверку корректности индекса в рамках границ, 
        /// и генерацию соответствующего исключения, если обращение некорректно;
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public T GetItem(int index)
        {
            // ваш код
            return default(T);
        }
        /// <summary>
        /// Метод добавления нового элемента в конец массива,
        /// </summary>
        /// <param name="itm"></param>
        public void Append(T itm)
        {
            // ваш код
        }
        /// <summary>
        /// Метод, который вставляет в i-ю позицию объект item, 
        /// сдвигая вперёд все последующие элементы. 
        /// Учтите, что новая длина массива может превысить размер буфера.
        /// Важно, единственное исключение: для метода Insert() 
        /// параметр i может принимать значение, равное длине рабочего массива count, 
        /// в таком случае добавление происходит в его хвост.
        /// Если индекс i лежит вне допустимых границ, генерируйте исключение.
        /// </summary>
        /// <param name="itm"></param>
        /// <param name="index"></param>
        public void Insert(T itm, int index)
        {
            // ваш код
        }
        /// <summary>
        /// Метод, который удаляет объект из i-й позиции, 
        /// при необходимости выполняя сжатие буфера.
        /// Если индекс i лежит вне допустимых границ, генерируйте исключение.
        /// </summary>
        /// <param name="index"></param>
        public void Remove(int index)
        {
            // ваш код
        }
        static void Main()
        {
            //1-я часть
            //Node n1 = new(12);
            //Node n2 = new(55);
            //n1.next = n2;

            //LinkedList s_list = new LinkedList();
            //s_list.AddInTail(n1);
            //s_list.AddInTail(n2);
            //s_list.AddInTail(new Node(128));

            //Node my_node = s_list.Find(55);
            //Console.WriteLine(my_node.value);
            //Console.ReadKey();

            //var list1 = new List<int> {12, 55, 56 };
            //LinkedList<int> nodes1 = new LinkedList<int>(list1);
            //var list2 = new List<int> { 11, 0, 2 };
            //LinkedList<int> nodes2 = new LinkedList<int>(list1);
            //List<int> result = new List<int>();

            //foreach (int item in result)
            //{
            //    Console.Write(" "+ InsertAfter(list1., nodes2));
            //}            
            //Console.ReadKey();
            //-------------------
            //Node n1 = new(12);
            //Node n2 = new(55);
            //n1.next = n2;

            //LinkedList s_list2 = new LinkedList();
            //s_list2.AddInTail(n1);
            //s_list2.AddInTail(n2);
            //s_list2.AddInTail(new Node(128));
            //s_list2.AddInTail(new Node(55));

            //List<int> print_nodes = new List<int>();
            //s_list2.PrintAllNodes();

            //foreach (var item in s_list2.PrintAllNodes())
            //{
            //    Console.Write(" " + item);
            //}
            //Console.WriteLine(print_nodes.Count());
            //s_list2.RemoveAll(n2.value);
            //s_list2.PrintAllNodes();
            //Console.ReadKey();
        }
    }
}

