using System;
using System.Collections.Generic;

namespace AlgorithmsDataStructures
{
    /// <summary>
    /// Динамические массивы
    /// </summary>
    #region Теория
    //У списков есть свои неоспоримые преимущества, но есть и один недостаток -- мы не можем обратиться к конкретному элементу быстро, по индексу, одним обращением. Сложность операции выборки i-го элемента, очевидно, O(n) -- нам надо, в наихудшем случае, пробежаться по всему списку с начала до конца. А массивы через индексирование обычно предоставляют меру O(1) -- то есть не зависящую от размера массива. И мы при этом хотим работать с массивами, как с динамическими объектами -- чтобы они автоматически расширялись при добавлении в них элемента.//    Практически во всех современных языках поддерживается тип данных "список", как минимум на уровне стандартных библиотек, который в принципе полностью отвечает требованиям динамического массива.Список обычно индексируется, позволяет добавлять элементы в позицию по индексу, автоматически расширяется когда в него добавляются новые элементы, и сжимается при удалении элементов.
    //   Схемы реаллокации
    //   Схем увеличения буфера (реаллокации массива) две: аддитивная и мультипликативная.
    //   Аддитивная схема обычно применяется, когда размер массива небольшой, и расходы на реаллокацию невелики.В таком случае экономичнее увеличивать его размер относительно небольшими фиксированными порциями.Мультипликативная схема подразумевает достаточно сильное изменение размера -- в разы, так как реаллокация крупного массива потребует существенных ресурсов. Обычно он удваивается.Пример мультипликативной схемы, принятой в стандартной библиотеке Java:
    //   size = (size * 3) / 2 + 1
    //   Часто применяется и отношение "золотого сечения" 1,618.
    //   В целом, политика регулирования такого размера сильно зависит от конкретной решаемой задачи.
    //   Важно.В тестах используется схема, когда увеличение буфера происходит в два раза, а уменьшение в полтора раза (текущее значение размера буфера делится на 1.5, и результат приводится к целому типу, никаких округлений!). При этом сохраняем минимальную ёмкость 16 элементов.То есть если после деления на 1.5 получается меньше 16 элементов, то принимаем новый размер буфера 16 элементов.
    // Увеличение буфера выполняем, когда он весь полностью заполнен, и выполняется попытка добавления.Сокращение буфера выполняем, когда его заполненность после операции удаления станет строго меньше, чем заданный процент заполнения. В тестах используйте этот процент равным 50%.
    //Придерживайтесь этой схемы в своём коде для успешного тестирования.
    //2. Анализ мультипликативной схемы с помощью банковского метода
    // В общем случае недостаток мультипликативной схемы в том, что размер массива будет увеличиваться в геометрической прогрессии, а желаемая сложность O(1) в реальности будет o(1) (в среднем). Если вставка попадёт на реаллокацию, задержка времени может быть существенной.Поэтому в противовес так называемому агрегированному методу анализа сложности(и, соответственно выбору метода реаллокации), который подразумевает вычисление итоговой суммарной оценки всех операций(общее время работы) применяют банковский метод.
    //Его идея в том, что дешёвые операции мы делаем чуть дороже, чем они реально стоят, а дорогие наоборот подешевле.При этом удаётся поддерживать всё время положительный баланс, несмотря на то, что дорогие операции по абсолютной цене могут уводить его в минус.
    //Например, каждый случай вставки элемента, когда реаллокации не происходит, и каждый случай копирования элемента при копировании, можно оценивать не в одну условную операцию записи, а в три.Как только накапливается достаточная сумма, чтобы оплатить очередную реаллокацию, она выполняется. Причём цена её зависит от количества элементов в массиве и выбирается например, как степень двойки, не превышающая новый размер буфера.
    //3. Реализация динамического массива на практике
    //Мы смоделируем работу динамического массива вручную.
    //В классе DynArray потребуются три поля: count -- текущее количество элементов в массиве, capacity -- текущая ёмкость буфера (исходно 16 единиц), и array -- по сути, указатель на блок памяти нужной ёмкости.
    //Как лучше реализовать поле array? Дело в том, что не во всех языках разрешено напрямую работать с памятью.
    //Стандартный рекомендуемый здесь приём -- array хранит массив фиксированной длины с объектами некоторого базового типа, к которому приводятся все остальные типы.Когда мы расширяем или уменьшаем размер array, мы просто пересоздаём его с новым размером, и затем копируем объекты(по сути, указатели) в массив нового размера.Это копирование выполняется очень быстро и практически не требует ресурсов.Более того, во многих языках имеется стандартная операция копирования массивов.
    //4. Общие рекомендации
    //Если вам понадобится запрограммировать некоторую структуру данных, которую удобно сделать как связный список или как динамический массив, что лучше выбрать? Если элементов немного, то проще использовать самый обычный массив фиксированного размера с гарантированным запасом места (не важно, будет его размер 100 или 200 элементов, если их точно не будет больше верхней границы). А если их наоборот очень много, то плох будет и список, и динамический массив: первый слишком долго перебирать, а второй слишком долго расширять.Поэтому на практике например используется гибридная схема динамический "массиво-список": список составляется не из отдельных элементов, а из блоков (массивов фиксированного размера), которые сцепляются в список по мере роста числа элементов.При этом сам список относительно небольшой, поэтому его сканирование за O(N) вполне допустимо, а наращивание размера за счёт добавления фиксированных блоков выполняется за O(1). Внутри же этих блоков обращение к элементам также осуществляется за O(1). Но при этом, конечно, придётся пожертвовать временем доступа к конкретным значениям.
    //В целом, очень полезная практика -- комбинирование разных структур данных в одной, прежде всего из соображений масштабируемости.Когда данных для хранения слишком много, использовать одну классическую, "чистую" базовую структуру данных не всегда оптимально. Надо подумать, можно ли выделить во входных данных какие-то блоки, в которых имеется своя внутренняя структура, внутренняя организация, и применять для них наиболее подходящие типы данных, которые уже глобально связывать чем-то простым вроде списка или массива. Старайтесь применять такой подход и в дальнейшем, прикидывайте, как можно формировать эффективные композиции различных структур данных.
    #endregion
    #region Задания.
    //1. Нам потребуются такие базовые методы:
    //- формирование блока памяти заданного размера: MakeArray(int new_capacity). Метод меняет размер массива array, копируя при необходимости текущие объекты вышеописанным способом;
    //- получение объекта по его индексу GetItem(int i). В этот метод встроим проверку корректности индекса в рамках границ, и генерацию соответствующего исключения, если обращение некорректно;
    //- добавление нового элемента в конец массива, метод Append(item) .
    //Важно.В тестах используется схема, когда увеличение буфера происходит в два раза, а уменьшение в полтора раза(текущее значение размера буфера делится на 1.5, и результат приводится к целому типу). При этом сохраняем минимальную ёмкость 16 элементов.
    //Придерживайтесь этой схемы в своём коде для успешного тестирования.
    //2. Добавьте метод Insert(item, i), который вставляет в i-ю позицию объект item, сдвигая вперёд все последующие элементы.Учтите, что новая длина массива может превысить размер буфера.
    //3. Добавьте метод Remove(i), который удаляет объект из i-й позиции, при необходимости выполняя сжатие буфера.
    //В обоих случаях, если индекс i лежит вне допустимых границ, генерируйте исключение.
    //Важно, единственное исключение: для метода Insert() параметр i может принимать значение, равное длине рабочего массива count, в таком случае добавление происходит в его хвост.
    //4. Оцените меры сложности для этих двух методов.
    //5. Напишите тесты, проверяющие работу методов Insert() и Remove():
    //-- вставка элемента, когда в итоге размер буфера не превышен (проверьте также размер буфера);
    //-- вставка элемента, когда в результате превышен размер буфера(проверьте также корректное изменение размера буфера);
    //-- попытка вставки элемента в недопустимую позицию;
    //-- удаление элемента, когда в результате размер буфера остаётся прежним(проверьте также размер буфера);
    //-- удаление элемента, когда в результате понижается размер буфера(проверьте также корректное изменение размера буфера);
    //-- попытка удаления элемента в недопустимой позиции.
    #endregion

    public class DynArray<T>
    {
        /// <summary>
        /// Поле-указатель на блок памяти нужной ёмкости
        /// </summary>
        public T[] array; //array хранит массив фиксированной длины с объектами некоторого базового типа, к которому приводятся все остальные типы
        /// <summary>
        /// Поле - текущее количество элементов в массиве
        /// </summary>
        public int count;
        /// <summary>
        /// Поле - текущая ёмкость буфера (исходно 16 единиц)
        /// </summary>
        public int capacity;
        //private T[] array2;

        /// <summary>
        /// Конструктор класса
        /// </summary>
        public DynArray()
        {
            count = 0;
            array = new T[count];
            MakeArray(16);
        }
        /// <summary>
        /// Метод формирования блока памяти заданного размера
        /// </summary>
        /// <param name="new_capacity"></param>
        public void MakeArray(int new_capacity) //Стандартный рекомендуемый здесь приём -- array хранит массив фиксированной длины с объектами некоторого базового типа, к которому приводятся все остальные типы.Когда мы расширяем или уменьшаем размер array, мы просто пересоздаём его с новым размером, и затем копируем объекты(по сути, указатели) в массив нового размера.Это копирование выполняется очень быстро и практически не требует ресурсов.Более того, во многих языках имеется стандартная операция копирования массивов.
        {
            if (new_capacity < count)
                throw new ArgumentOutOfRangeException("Выход за пределы массива или пустой");

            Array.Resize(ref array, new_capacity);
            capacity = new_capacity;
            //array = new T[new_capacity]; //инициализируем массив
            //count = new_capacity; //устанавливаем текущее кол-во символов массива (текущая длина массива)
        }
        /// <summary>
        /// Метод получения объекта по его индексу: 
        /// В этот метод встроим проверку корректности индекса в рамках границ, 
        /// и генерацию соответствующего исключения, если обращение некорректно;
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public T GetItem(int index)
        {
            if ((index < 0 || index > count) || count == 0) //проверка корректности индекса в рамках границ
                throw new ArgumentOutOfRangeException("Выход за пределы массива или пустой");//генерациz соответствующего исключения, если обращение некорректно
            return array[index - 1];
            //return default(T);
        }
        /// <summary>
        /// Метод добавления нового элемента в конец массива,
        /// </summary>
        /// <param name="itm"></param>
        public void Append(T itm)
        {
            ////длина массива превышает размер буфера
            ////Увеличение буфера выполняем, когда он весь полностью заполнен, и выполняется попытка добавления.
            if (count >= capacity)
            {
                while (count > capacity) //не верим тому кто формирует массив и передает заведомо некорректные сведения
                    MakeArray(2 * capacity); //увеличиваем размер буфера в два раза
            }
            //array[oldcount] = itm;
            //count++;
            if (count == capacity)
            {
                int newCapacity = capacity * 2;
                var newArray = new T[newCapacity];
                for (int i = 0; i < count; i++)
                {
                    newArray[i] = array[i];
                }
                array = newArray;
                capacity *= 2;
            }
            array[count] = itm;
            count++;
        }
        /// <summary>
        /// Метод, который вставляет в i-ю позицию объект item, 
        /// сдвигая вперёд все последующие элементы. 
        /// Учтите, что новая длина массива может превысить размер буфера.
        /// Важно, единственное исключение: для метода Insert() 
        /// параметр i может принимать значение, равное длине рабочего массива count, 
        /// в таком случае добавление происходит в его хвост.
        /// Если индекс i лежит вне допустимых границ, генерируйте исключение.
        /// </summary>
        /// <param name="itm"></param>
        /// <param name="index"></param>
        public void Insert(T itm, int index)
        {
            if (count == capacity)
                Resize(2 * capacity);

            if (index <= 0 || index > count)
                throw new ArgumentOutOfRangeException("Выход за пределы массива или пустой");

            if (index == count)
            {
                Array.Resize(ref array, count + 1);
                //array[count++] = itm; 
                Append(itm);
                return;
            }
            GetItem(index); //проверяем в нужном ли диапазоне номер позиции index
            // сдвигаем все элементы вправо до нужного индекса
            for (int i = count - 1; i >= index - 1; i--)
                array[i + 1] = array[i];
            array[index] = itm;
            count++;
        }
        /// <summary>
        /// Метод, который удаляет объект из i-й позиции, 
        /// при необходимости выполняя сжатие буфера.
        /// Если индекс i лежит вне допустимых границ, генерируйте исключение.
        /// </summary>
        /// <param name="index"></param>
        public void Remove(int index)
        {
            if ((index < 0 || index > count) || count == 0)
                throw new ArgumentOutOfRangeException("Выход за пределы массива или пустой");

            for (int i = index + 1; i < count; i++)
                array[i - 1] = array[i];
            count--;

            if (count != 0)
            {
                if ((int)capacity / count < (int)capacity / 2)
                    _ = capacity / 1.5 < 16 ? capacity = 16 : (capacity = (int)(capacity / (decimal)1.5));
            }
            array[count] = default(T);
            ///смещает элементы, находящиеся правее переданного индекса, влево на 11 индекс, а затем удаляет последний элемент. Кидается ошибка, если массив пустой или же индекс находится за пределами массива:
            //MakeArray(capacity);
            ////count = 0;
            //for (int j = 0; j < array.Length; j++)
            //{
            //    if (j + count == array.Length) //фиксируем выход диапазона за длинну массива
            //        array[j] = default(T);
            //    if (j != index)
            //        array = default(T[]);
            //    if (j == index)
            //    {
            //        count--;
            //        array[array.Length - 1] = default(T);
            //    }
            //}
        }
        public void Resize(int new_capacity)
        {
            //if (count == 0)
            //throw new ArgumentOutOfRangeException("пустой");

            Array.Resize(ref array, new_capacity);

            MakeArray(new_capacity); //задаем блок памяти

            capacity = new_capacity;
        }
    }
    class CMain
    {
        public static void Main() { }
    }
}

