Задание №4.
1. Метод Insert() - "вставка в i-ю позицию объекта item, сдвигая вперёд все последующие элементы".
1.1. С изменением буфера (когда нет места): O(n), т.к. копируются элементы в новый массив.
1.2. Без изменения буфера (место есть): O(1).
2. Метод Remove(i), который удаляет объект из i-й позиции, при необходимости выполняя сжатие буфера
2.1. С изменением буфера (когда заполненность строго меньше 50%): т.к. сам массив не меняется, то O(1).
2.2. Без изменения буфера: 
2.2.1. Удаление последнего элемента: O(1).
2.2.2. Удаление непоследнего элемента: O(n) 
.........
комментарий
Если в массиве больше нет места для добавления нового элемента (физическое пространство заполнено), то создается новый массив, длины в несколько раз больше, чем было. Затем копируются все элементы на соответствующие ячейки, а затем добавляется новый элемент. 
Так как копируются все элементы, то асимптотическое время работы O(n).
Почему выделяется массив, длины в несколько раз больше, чем было? Чтобы среднее время (амортизированная сложность) вставки было )O(1). Если просто увеличить размер массива на 1, то при следующей вставке пришлось бы снова выделять массив размером на 1 элемент больше и копировать все элементы.
В разных языках программирование число кратного увеличения разное. Например в C# это число равно 2, то есть при каждом заполнении массива, происходит выделение памяти в два раза больше, чем было. 
Если же в массиве есть место для добавления нового элемента, то добавление по  индексу size происходит за константное время  O(1).
В итоге асимптотическое время работы это всегда худший случай, следовательно операция работает за линейное время O(n).
Запомните: если заранее известно количество элементов в массиве, то обязательно нужно выделять физическое пространство такого размера, чтобы добавление элементов в конец ВСЕГДА происходило за константное время.


Если в массиве нет места для добавления нового элемента, то создается новый массив, длины в несколько раз больше, чем было. Затем копируются все элементы на соответствующие ячейки (на 1 ячейку правее), а затем добавляется новый элемент в начало массива. Так как копируются все элементы, то время работы O(n).
Если же в массиве есть место для добавления нового элемента, то все элементы нужно сдвинуть на 1 индекс вправо. А затем записать в элемент под нулевым индексом нужное значение.
Заметим, что данная операция зависит от количества элементов в массиве, то есть время работы линейная O(n).
Алгоритм точно такой же как и при добавлении в начало. Единственное отличие в том, что сдвиг элементов происходит от нужного индекса, куда нужно вставить элемент. Обычно добавление в начало и добавление в произвольное место объединяют в один метод, так как алгоритм работы одинаковый.


2. Метод Remove(i), который удаляет объект из i-й позиции, при необходимости выполняя сжатие буфера
 При удалении элемента физический размер массива в памяти не меняется. Изменяется только логический размер. 
 Удаление последнего элемента.
Удаление последнего элемента не ведет к появлениям "дыр". Изменяется логическое пространство. Время получается O(1).
Удаление первого элемента.
При удалении первого элемента, нужно сдвинуть все элементы кроме первого на 1 индекс влево.? А затем удалить последний элемент массива
Заметим, что данная операция зависит от количества элементов в массиве, то есть время работы линейная O(n).
Удаление элемента на произвольном месте.
Алгоритм точно такой же как и при удалении первого элемента. Единственное отличие в том, что сдвиг элементов происходит от нужного индекса. Обычно удаление первого элемента и удаление элемента на произвольном месте объединяют в один метод, так как алгоритм работы одинаковый. 
Время работы линейная O(n)O(n)